[["index.html", "Blockchain Preface", " Blockchain Nicholas Lyu 2025-06-28 Preface These notes accompany the Summer 2025 self-learning of blockchain. "],["consensus.html", "1 Consensus Fundamental assumptions Single-shot consensus State-machine replication", " 1 Consensus Fundamental assumptions: digital signature and point-to-point communication 1.1. Other assumptions: permissioned setting 1.3, public-key infrastructure 1.4, and synchronous model 1.5. Single-shot concensus: Byzantine Broadcast 1.6 and Byzantine Agreement 1.9. Dolev-Strong (theorem 1.1): BB is solvable under permissioned setting, synchronous model, and PKI assumptions regardless of Byzantine portion. Equivalence of BA and BB when \\(f&lt;n/2\\): theorem 1.2. Multi-shot concensus: State-Machine Replication 1.10. Reduction to BB under permissioned setting and synchronous model (theorem 1.3). Fundamental assumptions Definition 1.1 (fundamental assumptions of blockchains) Throughout these notes, we assume the existence of: A correct, secure digital signature scheme (definition 1.2 below). Allows node \\(A\\) to verify \\(B\\)’s claim that “node \\(C\\) said …”. Point-to-point communication (internet). Minimal assumptions on latency / reliability. Definition 1.2 (digital signature scheme) A digital signature scheme consists of three algorithms, \\(\\mathrm{Gen}, \\mathrm{Sign}, \\mathrm{Vf}\\) satisfying: \\(\\mathrm{Gen}(1^\\lambda) = \\mathrm{pk, sk}\\): consumes a security parameter \\(\\lambda\\) to generate a (public, secret)-key pair. \\(\\mathrm{Sign}(\\mathrm{sk}, m) = \\sigma\\): consumes a secret key and a message to obtain a signature. \\(\\mathrm{Vf}(\\mathrm{pk}, m, \\sigma) = \\{0, 1\\}\\): verification consuming public key, message, and signature to output acceptance or rejection. A digital signature scheme \\((\\mathrm{Gen}, \\mathrm{Sign}, \\mathrm{Vf})\\) is: correct if \\(\\mathrm{Vf}(\\mathrm{pk}, m, \\mathrm{Sign}(\\mathrm{sk}, m)) = 1\\). secure if no poly-\\(\\lambda\\) adversary can forge an acceptable signature reliably. Note that the signature must be message-dependent, else signatures can be copied to sign other messages. We consider nodes, which are local computers which can run code and communicate with each other in a point-to-point fashion. A protocol is an algorithm which a node can run. Definition 1.3 (permissioned setting) The set of nodes responsible for running the protocol is known up front. In other words, the protocol description itself can reference specific nodes which are running it. For a company managing database copies, permissioned setting is natural. Bitcoin and Ethereum protocols are likely permissionless. Definition 1.4 (public key infrastructure) Stronger assumption than permissioned setting: all nodes have distinct public-private key pairs, and public keys are common knowledge. Definition 1.5 (synchronous model) The synchronous model, nodes have: Shared global clock: nodes can agree on a global timestep. Bounded message delays: w.l.o.g., message sent at time \\(t\\) will be delivered by \\(t+1\\). Single-shot consensus Consider a sequence of \\([n]=\\{1, 2, \\dots, n\\}\\) nodes. Given a protocol, nodes are of the following types; we may know a bound on the number of nodes in each type, but we do not know the nodes’ identity: Honest: executes the prescribed protocol. This includes both the validity and timeliness of messages. Byzantine: behaves arbitrarily; byzantine nodes can collude. Definition 1.6 (Byzantine Broadcast) We’re working in a permissioned setting. One node is the sender and the other non-senders. The sender’s identity is common knowledge. The sender has access to private input \\(v^*\\in V\\). A solution to the Byzantine broadcast problem must satisfy: Termination: every honest node \\(j\\) eventually halts with some output \\(v\\in V\\). Agreement: all honest nodes halt with the same output, irrespective of whether the sender is honest. Validity: if the sender is honest, then the common output of honest nodes is \\(v^*\\). Note that agreement without validity is trivial (all nodes output \\(\\perp\\)), as well as validity without agreement (echo sender). Also note that validity implies agreement when the sender is honest. Definition 1.7 (convincing message) Node \\(j\\) is convinced of value \\(v\\) at time \\(t\\) if it receives a message prior to \\(t\\) that: References \\(v\\). Signed first by the sender. Also signed by at least \\(t-1\\) distinct non-sender nodes apart from \\(j\\). Definition 1.8 (Dolev-Strong protocol) At \\(t=0\\), the sender sends \\(v^*\\) to all nodes and outputs \\(v^*\\). Next repeat for \\(t=1, \\dots, f+1\\): If a non-sender \\(j\\) is newly convinced of \\(v\\) at time \\(t\\) by message \\(m\\), the node adds its own signature to \\(m\\) and sends \\((m, s)\\) to all other non-senders. For each nonsender, if outputs \\(v\\) it’s convinced by exactly one \\(v\\), else outputs \\(\\perp\\). Theorem 1.1 (Dolev-Strong) Byzantine Broadcast 1.6 is solvable under: Permissioned setting with \\(n\\) nodes 1.3 under PKI assumptions 1.4. Synchronous communication 1.5. Arbitrary bound on Byzantine nodes. Note that the \\(f=n, n-1\\) case satisfies validity and agreement trivially. Proof idea: honest nodes broadcast what they’re convinced by, and protocol runs for long enough so that there’re not enough Byzantine nodes to collude Let’s first prove validity; considering an honest sender (validity only has bite for honest senders), an honest node can only ever be convinced of \\(v^*\\) since convincing messages has to be signed by the sender, and Byzantine nodes can’t forge the sender’s signature. Honest non-senders are also convinced by the honest sender at \\(t=0\\). Proceeding to agreement: validity implies agreement if the sender is honest. Assuming Byzantine sender, we prove that when protocol terminates, all honest non-senders are convinced of the same set of values. Assuming that an honest non-sender \\(j\\) is newly convinced at: \\(t\\leq f\\): this implies that the sender and \\(t-1\\) non-senders signed the message. Then \\(j\\) proceeds to sign the message and broadcast; this message convinces all non-senders at \\(t+1\\). \\(t=f+1\\): this implies that the Byzantine sender and \\(t-1=f\\) non-senders signed the message. Since there’re at most \\(f\\) Byzantine nodes, at least one honest non-sender has signed the message, so all other nodes are convinced. Note that the \\(t=f+1\\) round of checks is paramount; suppose we terminate at time \\(t\\), then the Byzantine nodes can collude to produce a convincing message to one of the honest nodes, which does not have time to broadcast this to other honest nodes. Definition 1.9 (Byzantine Agreement) Similar to Byzantine broadcast 1.6, but each node has private bit \\(b_j\\in \\{0, 1\\}\\) with at most \\(f\\) Byzantine nodes. Solution must satisfy termination and: Agreement: all honest nodes output the same bit. Validity: when all nodes have the same private input, they all terminate with \\(b\\). Theorem 1.2 (deterministic BA-BB reduction) Given \\(f&lt;n/2\\), there exists a deterministic BA solution iff there exists a deterministic BB solution. Given \\(\\pi\\) solving the BB problem, construct a BA protocol as follows: Nodes take turn to Byzantine-broadcast their private input \\(b_j\\). Output majority value. Validity: when all nodes have the same private input \\(b\\), their private inputs are consistently broadcasted to all other honest nodes since \\(\\pi\\) is valid. Since \\(f&lt;n/2\\), honest nodes have consistent output by majority vote. Consistency: all honest nodes have the same “perception” of other nodes, so majority votes are consistent. Given a BA protocol \\(\\pi\\), construct a BB protocol as follows: \\(T=0\\): non-senders run BA with \\(b_j=0\\), sender runs with \\(v^*\\). \\(T=1\\): non-senders run BA with \\(b_j=1\\), sender runs with \\(v^*\\). State-machine replication Byzantine broadcast is also known as a one-shot consensus problem. We proceed to multi-shot consensus and demonstrate reduction to Byzantine Broadcast. Definition 1.10 (state-machine replication) We’re working in a permissioned setting. Each honest node receives an incoming stream of requests and attempts to make this common knowledge; it also maintains an append-only log. A solution should satisfy Liveliness: every request to an honest node is eventually included in the log of honest nodes. Consistency: at any time, the log of each honest replica are pairwise prefixes (i.e. order cannot be messed up). Theorem 1.3 (SMR reduces to BB) In a synchronous and permissioned setting with PKI, given a BB protocol \\(\\pi\\) which terminates in time \\(T\\), there exists a solution to SMR. At each step \\(0, T, 2T, 3T, \\dots\\) Define the leader node by round-robin ordering. The leader collects its own not-yet-included requests and appends them to its local log. The leader broadcasts the updated local log via \\(\\pi\\). When \\(\\pi\\) terminates, every node \\(j\\) appends its not-yet-included requests to the received log. BB (validity, agreement)\\(\\implies\\) SMR (liveliness, consistency) Liveliness: request submitted to \\(j\\) will be included in the log of all honest nodes when it’s \\(j\\)’s term to be the leader, by \\(\\pi\\)’s validity property. Consistency: \\(\\pi\\)’s consistency implies that nodes execute the appending operation consistently. "],["bibliography.html", "Bibliography", " Bibliography "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
